# 模式开发工具使用指南

本指南介绍如何使用项目提供的各种工具类来简化模式插件的开发。

## 工具类概览

所有工具类都可以从 `@/utils/modeHelpers` 导入：

```javascript
import { 
  createStreamJsonParser, 
  createThrottle, 
  createScrollManager,
  createMetadataManager,
  createAbortManager 
} from '@/utils/modeHelpers';
```

## 1. StreamJsonParser - 流式JSON解析器

用于处理AI返回的不完整JSON流，特别适合需要解析JSON格式响应的模式。

### 基本使用

```javascript
export default {
  data() {
    return {
      jsonParser: createStreamJsonParser()
    };
  },
  methods: {
    async handleSend() {
      this.jsonParser.reset();
      
      await callAiModel({
        onChunk: (chunk) => {
          this.jsonParser.appendChunk(chunk.content);
        }
      });
      
      try {
        const data = this.jsonParser.parseComplete();
        console.log('解析结果:', data);
      } catch (e) {
        console.error('JSON解析失败');
      }
    }
  }
};
```

### API说明

- `reset()` - 重置解析器，清空缓冲区
- `appendChunk(newContent)` - 追加新的内容块
- `cleanJsonText(jsonText)` - 清理JSON文本，移除代码块标记
- `tryParse()` - 尝试解析，失败返回null
- `parseComplete()` - 解析完整JSON，失败抛出异常
- `getBuffer()` - 获取当前缓冲区内容
- `extractField(data, fieldName, defaultValue)` - 提取字段值

### 应用场景

- 虚拟恋人模式：解析包含角色状态、表情、动作的JSON响应
- 游戏模式：解析骰子结果、属性变化等结构化数据
- 任何需要AI返回结构化JSON的场景

## 2. ThrottleManager - 节流管理器

用于优化流式更新的性能，避免频繁的DOM更新。

### 基本使用

```javascript
export default {
  data() {
    return {
      throttleManager: createThrottle(50)
    };
  },
  methods: {
    updateUI() {
      this.throttleManager.execute(() => {
        this.chat.messages = [...this.chat.messages];
        this.$emit('update-chat', this.chat);
        this.$nextTick(() => {
          this.scrollToBottom();
        });
      });
    }
  },
  beforeUnmount() {
    this.throttleManager.cancel();
  }
};
```

### API说明

- `execute(callback)` - 执行回调，自动节流
- `cancel()` - 取消待执行的回调
- `isThrottled()` - 检查是否正在节流中

### 函数式用法

```javascript
import { throttle } from '@/utils/modeHelpers';

const updateUI = throttle(() => {
  console.log('更新UI');
}, 100);
```

## 3. ScrollManager - 滚动管理器

统一处理消息列表的滚动逻辑。

### 基本使用

```javascript
import { ref } from 'vue';

export default {
  setup() {
    const containerRef = ref(null);
    
    return {
      containerRef
    };
  },
  mounted() {
    this.scrollManager = createScrollManager(this.containerRef);
  },
  methods: {
    handleNewMessage() {
      this.scrollManager.scrollToBottom();
    },
    handleScroll() {
      const shouldShow = this.scrollManager.shouldShowScrollButton();
      this.$emit('scroll-bottom-changed', shouldShow);
    }
  }
};
```

### API说明

- `isNearBottom(threshold)` - 检查是否接近底部
- `getDistanceFromBottom()` - 获取距离底部的距离
- `scrollToBottom(force)` - 滚动到底部（可选强制）
- `scrollToBottomSmooth()` - 平滑滚动到底部
- `shouldShowScrollButton(threshold)` - 是否应显示滚动按钮

### 工具函数

```javascript
import { isScrolledToBottom, scrollElementToBottom } from '@/utils/modeHelpers';

if (isScrolledToBottom(element)) {
  console.log('已在底部');
}

scrollElementToBottom(element, true); // 平滑滚动
```

## 4. ModeMetadataManager - 元数据管理器

用于保存和加载模式特定的数据（如好感度、角色状态等）。

### 基本使用

```javascript
export default {
  mounted() {
    this.metadataManager = createMetadataManager(this.chat, 'loverData');
    
    const favorability = this.metadataManager.get('favorability', 50);
    console.log('当前好感度:', favorability);
  },
  methods: {
    updateFavorability(value) {
      this.metadataManager.set('favorability', value);
    },
    saveAllData(data) {
      this.metadataManager.setAll(data);
    },
    loadAllData() {
      return this.metadataManager.getAll();
    }
  }
};
```

### API说明

- `get(key, defaultValue)` - 获取值
- `set(key, value)` - 设置值
- `setAll(data)` - 批量设置
- `getAll()` - 获取所有数据
- `clear()` - 清空所有数据
- `has(key)` - 检查是否存在

### 工具函数

```javascript
import { loadMetadata, saveMetadata } from '@/utils/modeHelpers';

const data = loadMetadata(this.chat, 'gameState', { level: 1, exp: 0 });

saveMetadata(this.chat, 'gameState', { level: 2, exp: 100 });
```

## 5. AbortManager - 中止控制器管理器

统一管理AI请求的取消操作。

### 基本使用

```javascript
export default {
  data() {
    return {
      abortManager: createAbortManager()
    };
  },
  methods: {
    async handleSend() {
      const controller = this.abortManager.create();
      
      try {
        await callAiModel({
          signal: controller.signal,
          onChunk: (chunk) => {
            console.log(chunk);
          }
        });
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('请求已取消');
        }
      } finally {
        this.abortManager.abort();
      }
    },
    handleCancel() {
      this.abortManager.abort();
    }
  }
};
```

### API说明

- `create()` - 创建新的AbortController（会自动终止旧的）
- `abort()` - 终止当前请求
- `getSignal()` - 获取当前signal
- `isActive()` - 检查是否有活跃的控制器

## 完整示例

以下是一个结合所有工具的完整示例：

```javascript
import { 
  createStreamJsonParser, 
  createThrottle, 
  createMetadataManager,
  createAbortManager 
} from '@/utils/modeHelpers';
import { callAiModel } from '@/core/services/aiService';

export default {
  name: 'ExampleMode',
  data() {
    return {
      inputMessage: '',
      isTyping: false,
      jsonParser: createStreamJsonParser(),
      throttleManager: createThrottle(50),
      abortManager: createAbortManager()
    };
  },
  mounted() {
    this.metadataManager = createMetadataManager(this.chat, 'exampleData');
    this.loadState();
  },
  methods: {
    loadState() {
      const savedData = this.metadataManager.getAll();
      console.log('加载的数据:', savedData);
    },
    
    async handleSend() {
      if (!this.inputMessage.trim() || this.isTyping) return;
      
      const userMessage = { role: 'user', content: this.inputMessage.trim() };
      this.chat.messages.push(userMessage);
      
      this.inputMessage = '';
      this.isTyping = true;
      this.jsonParser.reset();
      this.throttleManager.cancel();
      
      const assistantMessage = { role: 'assistant', content: '' };
      this.chat.messages.push(assistantMessage);
      
      try {
        const controller = this.abortManager.create();
        
        await callAiModel({
          provider: this.config.provider,
          apiKey: this.config.apiKey,
          model: this.config.model,
          messages: this.chat.messages.slice(0, -1),
          signal: controller.signal,
          onChunk: (chunk) => {
            this.jsonParser.appendChunk(chunk.content);
            this.updateUIThrottled(assistantMessage);
          }
        });
        
        const data = this.jsonParser.parseComplete();
        assistantMessage.content = this.jsonParser.cleanJsonText(this.jsonParser.getBuffer());
        
        this.metadataManager.set('lastResponse', data);
        
      } catch (error) {
        console.error('AI调用失败:', error);
        this.chat.messages.pop();
      } finally {
        this.throttleManager.cancel();
        this.isTyping = false;
        this.abortManager.abort();
        this.$emit('update-chat', this.chat);
      }
    },
    
    updateUIThrottled(assistantMessage) {
      assistantMessage.content = this.jsonParser.getBuffer();
      
      this.throttleManager.execute(() => {
        this.chat.messages = [...this.chat.messages];
        this.$emit('update-chat', this.chat);
      });
    },
    
    handleCancel() {
      this.abortManager.abort();
    }
  }
};
```

## 最佳实践

1. **初始化时机**
   - 在 `data()` 中创建工具实例
   - 在 `mounted()` 中创建需要依赖其他数据的工具

2. **清理资源**
   - 在 `beforeUnmount()` 中取消节流器
   - 在请求结束时终止AbortController

3. **错误处理**
   - 使用 `tryParse()` 进行安全的JSON解析
   - 捕获 `AbortError` 判断是否为用户取消

4. **性能优化**
   - 使用节流器优化流式更新
   - 只在接近底部时自动滚动
   - 合理设置节流延迟（建议50ms）

## 工具扩展

如需添加新的工具类：

1. 在 `src/utils/` 下创建新文件
2. 导出工具类和创建函数
3. 在 `src/utils/modeHelpers.js` 中统一导出
4. 更新本文档

## 相关文档

- [架构说明](./架构说明.md)
- [新模式开发文档](./新模式开发文档.md)
- [插件开发示例](./插件开发示例.md)

