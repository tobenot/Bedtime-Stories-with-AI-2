# 微内核+插件化架构说明

## 架构概述

本项目已重构为**微内核+插件化架构**，将原本耦合在一起的功能模块解耦，使其更易于扩展和维护。

## 目录结构

```
src/
├── core/                      # 微内核核心代码
│   ├── services/              # 核心服务
│   │   └── aiService.js       # AI服务（统一的AI接口调用）
│   ├── pluginSystem.js        # 插件系统（插件注册、加载、管理）
│   └── store.js               # 全局状态管理
│
├── modes/                     # 模式插件目录
│   ├── StandardChatMode/      # 标准对话模式插件
│   │   ├── index.vue          # 插件主组件
│   │   ├── plugin.js          # 插件配置文件
│   │   └── components/        # 插件专用组件
│   └── index.js               # 模式注册中心
│
├── shared/                    # 共享资源
│   └── components/            # 可复用的UI组件
│       ├── MessageBubble.vue  # 消息气泡
│       ├── ChatInput.vue      # 输入框
│       ├── MarkdownRenderer.vue # Markdown渲染器
│       └── EmptyState.vue     # 空状态组件
│
├── tools/                     # 工具插件目录
│   ├── ScriptSelectorTool/    # 剧本选择器工具
│   │   ├── index.vue          # 工具主组件
│   │   └── tool.js            # 工具配置文件
│   └── index.js               # 工具注册中心
│
├── utils/                     # 工具函数
├── components/                # 原有的全局组件（设置、侧边栏等）
├── config/                    # 配置文件
├── AppCore.vue                # 微内核主应用
└── main.js                    # 应用入口
```

## 核心概念

### 1. 微内核 (AppCore.vue)

微内核是应用的中枢，负责：
- **插件加载与切换**：动态加载和切换不同的模式插件
- **全局状态管理**：管理AI配置、对话历史等全局状态
- **通用服务提供**：为插件提供AI服务、存储服务等
- **UI框架**：提供顶部栏、侧边栏等框架UI

### 2. 模式插件 (Modes)

模式插件是独立的功能模块，每个模式都是一个完整的Vue组件。特点：
- **独立性**：每个模式有自己的UI和逻辑
- **可插拔**：可以随时添加或移除模式
- **配置化**：通过plugin.js配置插件的元信息

#### 创建新模式插件

以创建"虚拟恋人模式"为例：

1. 创建插件目录结构：
```
src/modes/VirtualLoverMode/
├── index.vue          # 主组件
├── plugin.js          # 插件配置
└── components/        # 插件专用组件（可选）
```

2. 编写插件配置 (`plugin.js`)：
```javascript
import VirtualLoverMode from './index.vue';

export default {
  id: 'virtual-lover',
  name: '虚拟恋人',
  description: '与AI建立虚拟恋爱关系',
  icon: 'ChatDotRound',
  version: '1.0.0',
  author: 'tobenot',
  component: VirtualLoverMode,
  config: {
    // 插件特定配置
    supportFavorability: true,  // 支持好感度系统
    supportGifts: true           // 支持礼物系统
  }
};
```

3. 实现插件组件 (`index.vue`)：
```vue
<template>
  <div class="virtual-lover-mode">
    <!-- 左侧：对话区 -->
    <div class="chat-area">
      <!-- 使用共享组件 -->
      <MessageBubble 
        v-for="msg in messages" 
        :key="msg.id"
        :role="msg.role"
        :content="msg.content"
      />
      <ChatInput @send="handleSend" />
    </div>
    
    <!-- 右侧：状态面板 -->
    <div class="status-panel">
      <div class="favorability">
        好感度: {{ favorability }}%
      </div>
      <!-- 其他状态信息 -->
    </div>
  </div>
</template>

<script>
import { callAiModel } from '@/core/services/aiService';
import MessageBubble from '@/shared/components/MessageBubble.vue';
import ChatInput from '@/shared/components/ChatInput.vue';

export default {
  name: 'VirtualLoverMode',
  components: { MessageBubble, ChatInput },
  props: {
    config: Object,  // 从微内核传入的配置
    chat: Object     // 当前对话数据
  },
  data() {
    return {
      messages: [],
      favorability: 50
    };
  },
  methods: {
    async handleSend(message) {
      // 使用核心AI服务
      await callAiModel({
        provider: this.config.provider,
        apiKey: this.config.apiKey,
        model: this.config.model,
        messages: this.messages,
        onChunk: (chunk) => {
          // 处理流式返回
        }
      });
    }
  }
};
</script>
```

4. 在 `src/modes/index.js` 中注册插件：
```javascript
import VirtualLoverMode from './VirtualLoverMode/plugin';

export function registerAllModes() {
  pluginSystem.register(StandardChatMode);
  pluginSystem.register(VirtualLoverMode);  // 添加新插件
}
```

### 3. 工具插件 (Tools)

工具是可以附加到不同模式中的小功能，如骰子、生图等。

#### 创建新工具

以创建"骰子工具"为例：

1. 创建工具目录：
```
src/tools/DiceRollerTool/
├── index.vue          # 工具UI组件
└── tool.js            # 工具配置
```

2. 编写工具配置 (`tool.js`)：
```javascript
import DiceRollerTool from './index.vue';

export default {
  id: 'dice-roller',
  name: '骰子',
  description: '掷骰子进行随机检定',
  icon: 'Trophy',
  version: '1.0.0',
  component: DiceRollerTool,
  compatibleModes: ['standard-chat', 'game-mode'],  // 兼容的模式
  handler: (context, result) => {
    // 处理骰子结果，返回要插入到输入框的文本
    return `[骰子结果: ${result}]`;
  }
};
```

3. 在 `src/tools/index.js` 中注册：
```javascript
import DiceRollerTool from './DiceRollerTool/tool';

export function registerAllTools() {
  toolRegistry.register(ScriptSelectorTool);
  toolRegistry.register(DiceRollerTool);  // 添加新工具
}
```

### 4. 共享组件 (Shared Components)

位于 `src/shared/components/` 的可复用UI组件，所有插件都可以使用：

- **MessageBubble**: 消息气泡（支持用户/AI消息、思考过程等）
- **ChatInput**: 输入框（支持发送、取消、工具栏等）
- **MarkdownRenderer**: Markdown渲染器
- **EmptyState**: 空状态组件

使用方式：
```vue
<script>
import MessageBubble from '@/shared/components/MessageBubble.vue';
import ChatInput from '@/shared/components/ChatInput.vue';

export default {
  components: { MessageBubble, ChatInput }
};
</script>
```

### 5. 核心服务 (Core Services)

#### AI服务 (`core/services/aiService.js`)

统一的AI调用接口，支持多种提供商：

```javascript
import { callAiModel } from '@/core/services/aiService';

// 调用AI
await callAiModel({
  provider: 'gemini',
  apiKey: 'your-api-key',
  model: 'gemini-2.5-flash',
  messages: [
    { role: 'user', content: 'Hello!' }
  ],
  temperature: 0.7,
  maxTokens: 4096,
  onChunk: (chunk) => {
    // 处理流式返回的数据
    console.log(chunk);
  }
});
```

## 插件间通信

### 1. 通过Props接收配置

微内核会将全局配置传递给插件：

```vue
<script>
export default {
  props: {
    config: Object  // 包含 provider, apiKey, model 等
  }
};
</script>
```

### 2. 通过Emit发送事件

插件通过事件向微内核发送请求：

```vue
<template>
  <button @click="$emit('open-settings')">打开设置</button>
</template>

<script>
export default {
  emits: ['open-settings', 'create-chat', 'save-message']
};
</script>
```

### 3. 使用全局状态

需要跨插件共享的状态可以使用 `core/store.js`：

```javascript
import { globalState, updateState } from '@/core/store';

// 读取状态
console.log(globalState.provider);

// 更新状态（会自动持久化）
updateState('temperature', 0.8);
```

## 开发新功能的流程

### 开发新模式

1. 在 `src/modes/` 下创建新的插件目录
2. 实现插件组件和配置
3. 在 `src/modes/index.js` 中注册
4. 重启开发服务器，在模式选择器中即可看到新模式

### 开发新工具

1. 在 `src/tools/` 下创建新的工具目录
2. 实现工具组件和配置
3. 在 `src/tools/index.js` 中注册
4. 在需要使用该工具的模式中集成

## 优势

### 高内聚、低耦合
- 每个模式/工具都是独立的模块
- 修改一个模式不会影响其他模式
- 新增功能只需添加新插件，不需修改现有代码

### 可扩展性强
- 轻松添加新的AI能力（虚拟恋人、游戏、小说等）
- 工具可以在多个模式间复用
- 支持第三方插件（未来可能）

### 易于维护
- 代码结构清晰，职责明确
- 共享组件避免重复代码
- 核心服务统一管理，修改成本低

### 开发效率高
- 可以并行开发多个插件
- 复用共享组件和核心服务
- 插件热插拔，开发测试方便

## 未来扩展方向

1. **更多模式插件**
   - 虚拟恋人模式（好感度系统、送礼系统）
   - 游戏模式（骰子检定、属性系统）
   - 小说模式（章节管理、大纲生成）
   - 角色扮演模式（多角色切换）

2. **更多工具**
   - 骰子工具（支持各种骰子规则）
   - 生图工具（集成AI绘图）
   - 语音工具（TTS/STT）
   - 代码运行工具

3. **插件市场**
   - 支持导入/导出插件
   - 插件评分和评论
   - 插件版本管理

4. **高级特性**
   - 插件间通信机制
   - 插件依赖管理
   - 插件权限控制
   - 插件沙箱隔离

## 注意事项

1. **向后兼容**：原有的对话功能现在作为"标准对话模式"插件存在
2. **数据迁移**：现有的对话历史会自动迁移到新架构
3. **性能优化**：插件采用懒加载，只有激活的插件才会被加载
4. **开发约定**：
   - 插件ID使用 kebab-case 命名
   - 插件组件名使用 PascalCase 命名
   - 遵循Vue 3组合式API最佳实践

## 总结

通过微内核+插件化架构，我们将一个单一功能的聊天应用改造成了一个可扩展的AI能力平台。这为未来添加各种创新的AI交互方式提供了坚实的基础，同时保持了代码的清晰和可维护性。

